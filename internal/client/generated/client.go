// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for MetricMonitorParamsNullsMode.
const (
	MetricMonitorParamsNullsModeAllow   MetricMonitorParamsNullsMode = "allow"
	MetricMonitorParamsNullsModeConvert MetricMonitorParamsNullsMode = "convert"
	MetricMonitorParamsNullsModeForbid  MetricMonitorParamsNullsMode = "forbid"
)

// Defines values for MonitorState.
const (
	MonitorStateFiring MonitorState = "firing"
	MonitorStateOpen   MonitorState = "open"
	MonitorStatePaused MonitorState = "paused"
)

// Defines values for MonitorType.
const (
	MonitorTypeError  MonitorType = "error"
	MonitorTypeMetric MonitorType = "metric"
)

// Defines values for RepeatIntervalStrategy.
const (
	RepeatIntervalStrategyCustom  RepeatIntervalStrategy = "custom"
	RepeatIntervalStrategyDefault RepeatIntervalStrategy = "default"
)

// Error defines model for Error.
type Error struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error code
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// ErrorMonitorParams defines model for ErrorMonitorParams.
type ErrorMonitorParams struct {
	// Metrics List of error metrics to monitor
	Metrics []MetricDefinition `json:"metrics"`

	// Query Optional filter query for errors
	Query *string `json:"query,omitempty"`
}

// MetricDefinition defines model for MetricDefinition.
type MetricDefinition struct {
	// Alias Optional alias for the metric
	Alias *string `json:"alias,omitempty"`

	// Name Metric name
	Name string `json:"name"`
}

// MetricMonitorParams defines model for MetricMonitorParams.
type MetricMonitorParams struct {
	// CheckNumPoint Number of consecutive points that must breach threshold
	CheckNumPoint *int `json:"checkNumPoint,omitempty"`

	// Column Column name to evaluate in the query result
	Column string `json:"column"`

	// GroupingInterval Grouping interval in milliseconds
	GroupingInterval *float64 `json:"groupingInterval,omitempty"`

	// MaxAllowedValue Maximum allowed value for the metric
	MaxAllowedValue *float64 `json:"maxAllowedValue,omitempty"`

	// Metrics List of metrics to monitor
	Metrics []MetricDefinition `json:"metrics"`

	// MinAllowedValue Minimum allowed value for the metric
	MinAllowedValue *float64 `json:"minAllowedValue,omitempty"`

	// NullsMode How to handle null values
	NullsMode *MetricMonitorParamsNullsMode `json:"nullsMode,omitempty"`

	// Query UQL (Uptrace Query Language) query for metric evaluation
	Query string `json:"query"`

	// TimeOffset Time offset in milliseconds
	TimeOffset *float64 `json:"timeOffset,omitempty"`
}

// MetricMonitorParamsNullsMode How to handle null values
type MetricMonitorParamsNullsMode string

// Monitor defines model for Monitor.
type Monitor struct {
	// ChannelIds List of notification channel IDs
	ChannelIds *[]int64 `json:"channelIds,omitempty"`

	// CreatedAt Monitor creation timestamp
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id Monitor unique identifier
	Id string `json:"id"`

	// Name Monitor name
	Name string `json:"name"`

	// NotifyEveryoneByEmail Whether to notify all project members by email
	NotifyEveryoneByEmail *bool           `json:"notifyEveryoneByEmail,omitempty"`
	Params                Monitor_Params  `json:"params"`
	RepeatInterval        *RepeatInterval `json:"repeatInterval,omitempty"`

	// State Current monitor state
	State MonitorState `json:"state"`

	// TeamIds List of team IDs to notify
	TeamIds *[]int64 `json:"teamIds,omitempty"`

	// Type Type of monitor
	Type MonitorType `json:"type"`

	// UpdatedAt Monitor last update timestamp
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Monitor_Params defines model for Monitor.Params.
type Monitor_Params struct {
	union json.RawMessage
}

// MonitorState Current monitor state
type MonitorState string

// MonitorInput defines model for MonitorInput.
type MonitorInput struct {
	// ChannelIds List of notification channel IDs
	ChannelIds *[]int64 `json:"channelIds,omitempty"`

	// Name Monitor name
	Name string `json:"name"`

	// NotifyEveryoneByEmail Whether to notify all project members by email
	NotifyEveryoneByEmail *bool               `json:"notifyEveryoneByEmail,omitempty"`
	Params                MonitorInput_Params `json:"params"`
	RepeatInterval        *RepeatInterval     `json:"repeatInterval,omitempty"`

	// TeamIds List of team IDs to notify
	TeamIds *[]int64 `json:"teamIds,omitempty"`

	// Type Type of monitor
	Type MonitorType `json:"type"`
}

// MonitorInput_Params defines model for MonitorInput.Params.
type MonitorInput_Params struct {
	union json.RawMessage
}

// MonitorType Type of monitor
type MonitorType string

// RepeatInterval defines model for RepeatInterval.
type RepeatInterval struct {
	// Interval Custom interval in seconds (only for custom strategy)
	Interval *int64 `json:"interval,omitempty"`

	// Strategy Repeat interval strategy
	Strategy *RepeatIntervalStrategy `json:"strategy,omitempty"`
}

// RepeatIntervalStrategy Repeat interval strategy
type RepeatIntervalStrategy string

// MonitorId defines model for MonitorId.
type MonitorId = string

// ProjectId defines model for ProjectId.
type ProjectId = int64

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// CreateMonitorJSONRequestBody defines body for CreateMonitor for application/json ContentType.
type CreateMonitorJSONRequestBody = MonitorInput

// UpdateMonitorJSONRequestBody defines body for UpdateMonitor for application/json ContentType.
type UpdateMonitorJSONRequestBody = MonitorInput

// AsMetricMonitorParams returns the union data inside the Monitor_Params as a MetricMonitorParams
func (t Monitor_Params) AsMetricMonitorParams() (MetricMonitorParams, error) {
	var body MetricMonitorParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricMonitorParams overwrites any union data inside the Monitor_Params as the provided MetricMonitorParams
func (t *Monitor_Params) FromMetricMonitorParams(v MetricMonitorParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricMonitorParams performs a merge with any union data inside the Monitor_Params, using the provided MetricMonitorParams
func (t *Monitor_Params) MergeMetricMonitorParams(v MetricMonitorParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorMonitorParams returns the union data inside the Monitor_Params as a ErrorMonitorParams
func (t Monitor_Params) AsErrorMonitorParams() (ErrorMonitorParams, error) {
	var body ErrorMonitorParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorMonitorParams overwrites any union data inside the Monitor_Params as the provided ErrorMonitorParams
func (t *Monitor_Params) FromErrorMonitorParams(v ErrorMonitorParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorMonitorParams performs a merge with any union data inside the Monitor_Params, using the provided ErrorMonitorParams
func (t *Monitor_Params) MergeErrorMonitorParams(v ErrorMonitorParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Monitor_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Monitor_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMetricMonitorParams returns the union data inside the MonitorInput_Params as a MetricMonitorParams
func (t MonitorInput_Params) AsMetricMonitorParams() (MetricMonitorParams, error) {
	var body MetricMonitorParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricMonitorParams overwrites any union data inside the MonitorInput_Params as the provided MetricMonitorParams
func (t *MonitorInput_Params) FromMetricMonitorParams(v MetricMonitorParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricMonitorParams performs a merge with any union data inside the MonitorInput_Params, using the provided MetricMonitorParams
func (t *MonitorInput_Params) MergeMetricMonitorParams(v MetricMonitorParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorMonitorParams returns the union data inside the MonitorInput_Params as a ErrorMonitorParams
func (t MonitorInput_Params) AsErrorMonitorParams() (ErrorMonitorParams, error) {
	var body ErrorMonitorParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorMonitorParams overwrites any union data inside the MonitorInput_Params as the provided ErrorMonitorParams
func (t *MonitorInput_Params) FromErrorMonitorParams(v ErrorMonitorParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorMonitorParams performs a merge with any union data inside the MonitorInput_Params, using the provided ErrorMonitorParams
func (t *MonitorInput_Params) MergeErrorMonitorParams(v ErrorMonitorParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MonitorInput_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonitorInput_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListMonitors request
	ListMonitors(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMonitorWithBody request with any body
	CreateMonitorWithBody(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMonitor(ctx context.Context, projectId ProjectId, body CreateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMonitor request
	DeleteMonitor(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMonitor request
	GetMonitor(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMonitorWithBody request with any body
	UpdateMonitorWithBody(ctx context.Context, projectId ProjectId, monitorId MonitorId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMonitor(ctx context.Context, projectId ProjectId, monitorId MonitorId, body UpdateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListMonitors(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMonitorsRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMonitorWithBody(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMonitorRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMonitor(ctx context.Context, projectId ProjectId, body CreateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMonitorRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMonitor(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMonitorRequest(c.Server, projectId, monitorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMonitor(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMonitorRequest(c.Server, projectId, monitorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMonitorWithBody(ctx context.Context, projectId ProjectId, monitorId MonitorId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMonitorRequestWithBody(c.Server, projectId, monitorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMonitor(ctx context.Context, projectId ProjectId, monitorId MonitorId, body UpdateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMonitorRequest(c.Server, projectId, monitorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListMonitorsRequest generates requests for ListMonitors
func NewListMonitorsRequest(server string, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/monitors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMonitorRequest calls the generic CreateMonitor builder with application/json body
func NewCreateMonitorRequest(server string, projectId ProjectId, body CreateMonitorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMonitorRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateMonitorRequestWithBody generates requests for CreateMonitor with any type of body
func NewCreateMonitorRequestWithBody(server string, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/monitors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMonitorRequest generates requests for DeleteMonitor
func NewDeleteMonitorRequest(server string, projectId ProjectId, monitorId MonitorId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "monitorId", runtime.ParamLocationPath, monitorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/monitors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMonitorRequest generates requests for GetMonitor
func NewGetMonitorRequest(server string, projectId ProjectId, monitorId MonitorId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "monitorId", runtime.ParamLocationPath, monitorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/monitors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMonitorRequest calls the generic UpdateMonitor builder with application/json body
func NewUpdateMonitorRequest(server string, projectId ProjectId, monitorId MonitorId, body UpdateMonitorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMonitorRequestWithBody(server, projectId, monitorId, "application/json", bodyReader)
}

// NewUpdateMonitorRequestWithBody generates requests for UpdateMonitor with any type of body
func NewUpdateMonitorRequestWithBody(server string, projectId ProjectId, monitorId MonitorId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "monitorId", runtime.ParamLocationPath, monitorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/monitors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListMonitorsWithResponse request
	ListMonitorsWithResponse(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*ListMonitorsResponse, error)

	// CreateMonitorWithBodyWithResponse request with any body
	CreateMonitorWithBodyWithResponse(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMonitorResponse, error)

	CreateMonitorWithResponse(ctx context.Context, projectId ProjectId, body CreateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMonitorResponse, error)

	// DeleteMonitorWithResponse request
	DeleteMonitorWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*DeleteMonitorResponse, error)

	// GetMonitorWithResponse request
	GetMonitorWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*GetMonitorResponse, error)

	// UpdateMonitorWithBodyWithResponse request with any body
	UpdateMonitorWithBodyWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMonitorResponse, error)

	UpdateMonitorWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, body UpdateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMonitorResponse, error)
}

type ListMonitorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Monitors []Monitor `json:"monitors"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListMonitorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMonitorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMonitorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Monitor Monitor `json:"monitor"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateMonitorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMonitorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMonitorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteMonitorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMonitorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMonitorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Monitor Monitor `json:"monitor"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMonitorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMonitorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMonitorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Monitor Monitor `json:"monitor"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateMonitorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMonitorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListMonitorsWithResponse request returning *ListMonitorsResponse
func (c *ClientWithResponses) ListMonitorsWithResponse(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*ListMonitorsResponse, error) {
	rsp, err := c.ListMonitors(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMonitorsResponse(rsp)
}

// CreateMonitorWithBodyWithResponse request with arbitrary body returning *CreateMonitorResponse
func (c *ClientWithResponses) CreateMonitorWithBodyWithResponse(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMonitorResponse, error) {
	rsp, err := c.CreateMonitorWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMonitorResponse(rsp)
}

func (c *ClientWithResponses) CreateMonitorWithResponse(ctx context.Context, projectId ProjectId, body CreateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMonitorResponse, error) {
	rsp, err := c.CreateMonitor(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMonitorResponse(rsp)
}

// DeleteMonitorWithResponse request returning *DeleteMonitorResponse
func (c *ClientWithResponses) DeleteMonitorWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*DeleteMonitorResponse, error) {
	rsp, err := c.DeleteMonitor(ctx, projectId, monitorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMonitorResponse(rsp)
}

// GetMonitorWithResponse request returning *GetMonitorResponse
func (c *ClientWithResponses) GetMonitorWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, reqEditors ...RequestEditorFn) (*GetMonitorResponse, error) {
	rsp, err := c.GetMonitor(ctx, projectId, monitorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMonitorResponse(rsp)
}

// UpdateMonitorWithBodyWithResponse request with arbitrary body returning *UpdateMonitorResponse
func (c *ClientWithResponses) UpdateMonitorWithBodyWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMonitorResponse, error) {
	rsp, err := c.UpdateMonitorWithBody(ctx, projectId, monitorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMonitorResponse(rsp)
}

func (c *ClientWithResponses) UpdateMonitorWithResponse(ctx context.Context, projectId ProjectId, monitorId MonitorId, body UpdateMonitorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMonitorResponse, error) {
	rsp, err := c.UpdateMonitor(ctx, projectId, monitorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMonitorResponse(rsp)
}

// ParseListMonitorsResponse parses an HTTP response from a ListMonitorsWithResponse call
func ParseListMonitorsResponse(rsp *http.Response) (*ListMonitorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMonitorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Monitors []Monitor `json:"monitors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateMonitorResponse parses an HTTP response from a CreateMonitorWithResponse call
func ParseCreateMonitorResponse(rsp *http.Response) (*CreateMonitorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMonitorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Monitor Monitor `json:"monitor"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteMonitorResponse parses an HTTP response from a DeleteMonitorWithResponse call
func ParseDeleteMonitorResponse(rsp *http.Response) (*DeleteMonitorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMonitorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMonitorResponse parses an HTTP response from a GetMonitorWithResponse call
func ParseGetMonitorResponse(rsp *http.Response) (*GetMonitorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMonitorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Monitor Monitor `json:"monitor"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateMonitorResponse parses an HTTP response from a UpdateMonitorWithResponse call
func ParseUpdateMonitorResponse(rsp *http.Response) (*UpdateMonitorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMonitorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Monitor Monitor `json:"monitor"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
